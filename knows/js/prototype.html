<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>JS基础-原型、原型链 | 网格公共组件</title>
    <meta name="generator" content="VuePress 1.7.1">
    <link rel="icon" href="/vue-press-grid/logo.ico">
    <meta name="description" content="前端开发 lhs的个人博客">
    
    <link rel="preload" href="/vue-press-grid/assets/css/0.styles.ccc93e22.css" as="style"><link rel="preload" href="/vue-press-grid/assets/js/app.ced59b00.js" as="script"><link rel="preload" href="/vue-press-grid/assets/js/2.b1aa8411.js" as="script"><link rel="preload" href="/vue-press-grid/assets/js/24.189c29c1.js" as="script"><link rel="prefetch" href="/vue-press-grid/assets/js/10.46e43940.js"><link rel="prefetch" href="/vue-press-grid/assets/js/11.ff20c055.js"><link rel="prefetch" href="/vue-press-grid/assets/js/12.adec604f.js"><link rel="prefetch" href="/vue-press-grid/assets/js/13.c54df519.js"><link rel="prefetch" href="/vue-press-grid/assets/js/14.43a4a675.js"><link rel="prefetch" href="/vue-press-grid/assets/js/15.706b8783.js"><link rel="prefetch" href="/vue-press-grid/assets/js/16.7b13045c.js"><link rel="prefetch" href="/vue-press-grid/assets/js/17.cd84bd66.js"><link rel="prefetch" href="/vue-press-grid/assets/js/18.26f532b5.js"><link rel="prefetch" href="/vue-press-grid/assets/js/19.01a73514.js"><link rel="prefetch" href="/vue-press-grid/assets/js/20.18231acd.js"><link rel="prefetch" href="/vue-press-grid/assets/js/21.159623fe.js"><link rel="prefetch" href="/vue-press-grid/assets/js/22.11ca97cf.js"><link rel="prefetch" href="/vue-press-grid/assets/js/23.57df14b1.js"><link rel="prefetch" href="/vue-press-grid/assets/js/25.7052d2ff.js"><link rel="prefetch" href="/vue-press-grid/assets/js/26.2f022016.js"><link rel="prefetch" href="/vue-press-grid/assets/js/27.a9c6b185.js"><link rel="prefetch" href="/vue-press-grid/assets/js/28.d0d6a883.js"><link rel="prefetch" href="/vue-press-grid/assets/js/29.1d1e3830.js"><link rel="prefetch" href="/vue-press-grid/assets/js/3.d578f5e6.js"><link rel="prefetch" href="/vue-press-grid/assets/js/30.e7bdcef3.js"><link rel="prefetch" href="/vue-press-grid/assets/js/31.6bb0cd5d.js"><link rel="prefetch" href="/vue-press-grid/assets/js/4.229a3a61.js"><link rel="prefetch" href="/vue-press-grid/assets/js/5.a27ddcbd.js"><link rel="prefetch" href="/vue-press-grid/assets/js/6.12c1d182.js"><link rel="prefetch" href="/vue-press-grid/assets/js/7.06af1b1d.js"><link rel="prefetch" href="/vue-press-grid/assets/js/8.bc7271fc.js"><link rel="prefetch" href="/vue-press-grid/assets/js/9.21eba4e4.js">
    <link rel="stylesheet" href="/vue-press-grid/assets/css/0.styles.ccc93e22.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/vue-press-grid/" class="home-link router-link-active"><!----> <span class="site-name">网格公共组件</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/vue-press-grid/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/vue-press-grid/grid-cube/" class="nav-link">
  cube-ui组件
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="知识点" class="dropdown-title"><span class="title">知识点</span> <span class="arrow down"></span></button> <button type="button" aria-label="知识点" class="mobile-dropdown-title"><span class="title">知识点</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vue-press-grid/knows/vue/" class="nav-link">
  vue知识点
</a></li><li class="dropdown-item"><!----> <a href="/vue-press-grid/knows/js/" class="nav-link router-link-active">
  js知识点
</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/vue-press-grid/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/vue-press-grid/grid-cube/" class="nav-link">
  cube-ui组件
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="知识点" class="dropdown-title"><span class="title">知识点</span> <span class="arrow down"></span></button> <button type="button" aria-label="知识点" class="mobile-dropdown-title"><span class="title">知识点</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vue-press-grid/knows/vue/" class="nav-link">
  vue知识点
</a></li><li class="dropdown-item"><!----> <a href="/vue-press-grid/knows/js/" class="nav-link router-link-active">
  js知识点
</a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/vue-press-grid/knows/js/" aria-current="page" class="sidebar-link">Javascript</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>js知识点</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/vue-press-grid/knows/js/array-api.html" class="sidebar-link">数组API解析合集</a></li><li><a href="/vue-press-grid/knows/js/call-apply.html" class="sidebar-link">JS基础系列-重新认识call apply bind</a></li><li><a href="/vue-press-grid/knows/js/cookie-storage.html" class="sidebar-link">cookie、localStorage 和 sessionStorage 的使用以及区别</a></li><li><a href="/vue-press-grid/knows/js/js-inherit.html" class="sidebar-link">JS基础-深入浅出继承</a></li><li><a href="/vue-press-grid/knows/js/Object.defineProperty.html" class="sidebar-link">一次弄懂 Object.defineProperty</a></li><li><a href="/vue-press-grid/knows/js/prototype.html" aria-current="page" class="active sidebar-link">JS基础-原型、原型链</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vue-press-grid/knows/js/prototype.html#prototype" class="sidebar-link">prototype</a></li><li class="sidebar-sub-header"><a href="/vue-press-grid/knows/js/prototype.html#原型链" class="sidebar-link">原型链</a></li><li class="sidebar-sub-header"><a href="/vue-press-grid/knows/js/prototype.html#扩展" class="sidebar-link">扩展：</a></li></ul></li><li><a href="/vue-press-grid/knows/js/shakeOrthrottle.html" class="sidebar-link">/knows/js/shakeOrthrottle.html</a></li><li><a href="/vue-press-grid/knows/js/WebSocket.html" class="sidebar-link">手摸手教你使用WebSocket</a></li><li><a href="/vue-press-grid/knows/js/webWorker.html" class="sidebar-link">前端er来学习一下webWorker吧</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="js基础-原型、原型链"><a href="#js基础-原型、原型链" class="header-anchor">#</a> JS基础-原型、原型链</h1> <p>JS的原型、原型链一直是比较难理解的内容，不少初学者甚至有一定经验的老鸟都不一定能完全说清楚，更多的&quot;很可能&quot;是一知半解，而这部分内容又是JS的核心内容，想要技术进阶的话肯定不能对这个概念一知半解，碰到问题靠“猜”，却不理解它的规则！</p> <h2 id="prototype"><a href="#prototype" class="header-anchor">#</a> prototype</h2> <h3 id="只有函数有prototype属性"><a href="#只有函数有prototype属性" class="header-anchor">#</a> 只有函数有prototype属性</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">let</span> <span class="token function-variable function">b</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span> <span class="token comment">// undefined</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span> <span class="token comment">// { constructor: function(){...} }</span>
</code></pre></div><h4 id="object-prototype怎么解释"><a href="#object-prototype怎么解释" class="header-anchor">#</a> Object.prototype怎么解释？</h4> <p>其实<code>Object</code>是一个全局对象，也是一个构造函数，以及其他基本类型的全局对象也都是构造函数：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">outTypeName</span><span class="token punctuation">(</span><span class="token parameter">data<span class="token punctuation">,</span> type</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> typeName <span class="token operator">=</span>  <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>typeName<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">outTypeName</span><span class="token punctuation">(</span>Object<span class="token punctuation">)</span> <span class="token comment">//[object Function]</span>
<span class="token function">outTypeName</span><span class="token punctuation">(</span>String<span class="token punctuation">)</span> <span class="token comment">// [object Function]</span>
<span class="token function">outTypeName</span><span class="token punctuation">(</span>Number<span class="token punctuation">)</span> <span class="token comment">// [object Function]</span>
</code></pre></div><h3 id="为什么只有函数有prototype属性"><a href="#为什么只有函数有prototype属性" class="header-anchor">#</a> 为什么只有函数有prototype属性</h3> <p>JS通过<code>new</code>来生成对象，但是仅靠构造函数，每次生成的对象都不一样。</p> <p>有时候需要在两个对象之间共享属性，由于JS在设计之初没有类的概念，所以JS使用函数的<code>prototype</code>来处理这部分<strong>需要被共享的属性</strong>，通过函数的<code>prototype</code>来模拟类：</p> <p>当创建一个函数时，JS会自动为函数添加<code>prototype</code>属性，值是一个有<code>constructor</code>的对象。</p> <p>以下是共享属性<code>prototype</code>的栗子：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">People</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
<span class="token punctuation">}</span>
<span class="token class-name">People</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">23</span> <span class="token comment">// 岁数</span>
<span class="token comment">// 创建两个实例</span>
<span class="token keyword">let</span> People1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">People</span><span class="token punctuation">(</span><span class="token string">'OBKoro1'</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> People2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">People</span><span class="token punctuation">(</span><span class="token string">'扣肉'</span><span class="token punctuation">)</span>
<span class="token class-name">People</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">24</span> <span class="token comment">// 长大了一岁</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>People1<span class="token punctuation">.</span>age<span class="token punctuation">,</span> People2<span class="token punctuation">.</span>age<span class="token punctuation">)</span> <span class="token comment">// 24 24</span>
</code></pre></div><p><strong>为什么<code>People1</code>和<code>People2</code>可以访问到<code>People.prototype.age</code></strong>？</p> <p>原因是：<code>People1</code>和<code>People2</code>的原型是<code>People.prototype</code>，答案在下方的：构造函数是什么以及它做了什么。</p> <h2 id="原型链"><a href="#原型链" class="header-anchor">#</a> 原型链</h2> <h3 id="proto-和object-getprototypeof-target-对象的原型"><a href="#proto-和object-getprototypeof-target-对象的原型" class="header-anchor">#</a> <code>__proto__</code>和<code>Object.getPrototypeOf(target)</code>： 对象的原型</h3> <p><code>__proto__</code>是对象实例和它的构造函数之间建立的链接，它的值是：构造函数的`prototype。</p> <p>也就是说：<code>__proto__</code>的值是它所对应的原型对象，是某个函数的<code>prototype</code></p> <p><code>Object.getPrototypeOf(target)</code>全等于<code>__proto__</code>。</p> <p>它是ES6的标准，兼容IE9，主流浏览器也都支持，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/GetPrototypeOf#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9" target="_blank" rel="noopener noreferrer">MDN<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，本文将以<code>Object.getPrototypeOf(target)</code>指代<code>__proto__</code>。</p> <h3 id="不要再使用-proto"><a href="#不要再使用-proto" class="header-anchor">#</a> 不要再使用<code>__proto__</code>:</h3> <blockquote><p>本段摘自<a href="http://es6.ruanyifeng.com/#docs/object-methods#__proto__%E5%B1%9E%E6%80%A7%EF%BC%8CObject-setPrototypeOf%EF%BC%8CObject-getPrototypeOf" target="_blank" rel="noopener noreferrer">阮一峰-ES6入门<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，具体解析请点击链接查看</p></blockquote> <ol><li><p><code>__proto__</code>属性没有写入 ES6 的正文，而是写入了附录。</p></li> <li><p>原因是它本质上是一个内部属性，而<strong>不是一个正式的对外的 API，只是由于浏览器广泛支持，才被加入了 ES6</strong>。</p></li> <li><p>标准明确规定，只有浏览器必须部署这个属性，<strong>其他运行环境不一定需要部署，而且新的代码最好认为这个属性是不存在的</strong>。</p></li> <li><p>所以无论从语义的角度，还是从兼容性的角度，都不要使用这个属性，应该使用：<code>Object.getPrototypeOf(target)</code>（读操作）、<code>Object.setPrototypeOf(target)</code>（写操作）、<code>Object.create(target)</code>（生成操作）代替</p></li></ol> <h3 id="构造函数是什么、它做了什么"><a href="#构造函数是什么、它做了什么" class="header-anchor">#</a> 构造函数是什么、它做了什么</h3> <blockquote><p>出自《你不知道的在js》：在js中, 实际上并不存在所谓的'构造函数'，只有对于函数的'构造调用'。</p></blockquote> <p>上文一直提到构造函数，所谓的构造函数，实际上就是通过关键字<code>new</code>来调用的函数：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> newObj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">someFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 构造调用函数</span>
</code></pre></div><p><strong>构造/new调用函数的时候做了什么</strong>：</p> <ol><li>创建一个全新的对象。</li> <li>这个新对象的原型(<code>Object.getPrototypeOf(target)</code>)指向构造函数的<code>prototype</code>对象。</li> <li>该函数的this会绑定在新创建的对象上。</li> <li>如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象。</li> <li>我们称这个新对象为构造函数的实例。</li></ol> <p><strong>原型继承就是利用构造调用函数的特性</strong>：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">SubType</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SuperType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 原型继承：SubType继承SuperType</span>
<span class="token class-name">SubType</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> SubType <span class="token comment">// 重新指定constructor指向 方便找到构造函数</span>
<span class="token comment">// 挂载SuperType的this和prototype的属性和方法到SubType.prototype上</span>
</code></pre></div><ol><li>构造调用的第二点：将新对象的<code>Object.getPrototypeOf(target)</code>指向函数的<code>prototype</code></li> <li>构造调用的第三点：该函数的this会绑定在新创建的对象上。</li> <li>新对象赋值给<code>SubType.prototype</code></li></ol> <p>原型类型有个缺点：多个实例对引用类型的操作会被篡改。</p> <blockquote><p>因为每次实例化引用类型的数据都指向同一个地址，所以它们读/写的是同一个数据，当一个实例对其进行操作，其他实例的数据就会一起更改。</p></blockquote> <h3 id="原型链是什么"><a href="#原型链是什么" class="header-anchor">#</a> 原型链是什么</h3> <p>来看个例子：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
<span class="token keyword">const</span> newObj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 构造调用foo 返回一个新对象</span>
<span class="token keyword">const</span> newObj__proto__ <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>newObj<span class="token punctuation">)</span> <span class="token comment">// 获取newObj的原型对象</span>
newObj__proto__ <span class="token operator">===</span> foo<span class="token punctuation">.</span>prototype <span class="token comment">// true 验证newObj的原型指向foo</span>
<span class="token keyword">const</span> foo__proto__ <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>foo<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span> <span class="token comment">// 获取foo.prototype的原型</span>
foo__proto__ <span class="token operator">===</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype <span class="token comment">// true foo.prototype的原型是Object.prototype</span>
<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token template-punctuation string">`</span></span>
如果用以前的语法，从<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">newObj</span><span class="token template-punctuation string">`</span></span>查找<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">foo</span><span class="token template-punctuation string">`</span></span>的原型，是这样的：
<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token template-punctuation string">`</span></span>`js
newObj<span class="token punctuation">.</span>__proto__<span class="token punctuation">.</span>__proto__ <span class="token comment">// 这种关系就是原型链</span>
</code></pre></div><p><strong>可以用以下三句话来理解原型链</strong>：</p> <ol><li><strong>每个对象都拥有一个原型对象</strong>: <code>newObj</code>的原型是<code>foo.prototype</code>。</li> <li><strong>对象的原型可能也是继承其他原型对象的</strong>: <code>foo.prototype</code>也有它的原型<code>Object.prototype</code>。</li> <li><strong>一层一层的，以此类推，这种关系就是原型链</strong>。</li></ol> <h3 id="一个对象是否在另一个对象的原型链上"><a href="#一个对象是否在另一个对象的原型链上" class="header-anchor">#</a> 一个对象是否在另一个对象的原型链上</h3> <blockquote><p>如果一个对象存在另一个对象的原型链上，我们可以说：它们是继承关系。</p></blockquote> <p>判断方式有两种，但都是根据构造函数的<code>prototype</code>是否在原型链上来判断的：</p> <ol><li><code>instanceof</code>: 用于测试构造函数的prototype属性是否出现在对象的原型链中的任何位置</li></ol> <p>语法：<code>object instanceof constructor</code></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> <span class="token function-variable function">test</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
<span class="token keyword">let</span> testObject <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
testObject <span class="token keyword">instanceof</span> <span class="token class-name">test</span> <span class="token comment">// true test.prototype在testObject的原型链上</span>
 testObject <span class="token keyword">instanceof</span> <span class="token class-name">Function</span> <span class="token comment">// false Function.prototype 不在testObject的原型链上</span>
testObject <span class="token keyword">instanceof</span> <span class="token class-name">Object</span> <span class="token comment">// true Object.prototype在testObject的原型链上</span>
</code></pre></div><ol start="2"><li><code>isPrototypeOf</code>：测试一个对象是否存在于另一个对象的原型链上</li></ol> <p>语法：<code>prototypeObj.isPrototypeOf(object)</code></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> <span class="token function-variable function">test</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
<span class="token keyword">let</span> testObject <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
test<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">isPrototypeOf</span><span class="token punctuation">(</span>testObject<span class="token punctuation">)</span> <span class="token comment">// true test.prototype在testObject的原型链上</span>
<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">isPrototypeOf</span><span class="token punctuation">(</span>testObject<span class="token punctuation">)</span> <span class="token comment">// true Object.prototype在testObject的原型链上</span>
</code></pre></div><h3 id="原型链的终点-object-prototype"><a href="#原型链的终点-object-prototype" class="header-anchor">#</a> 原型链的终点: <code>Object.prototype</code></h3> <p><code>Object.prototype</code>是原型链的终点，所有对象都是从它继承了方法和属性。</p> <p><strong><code>Object.prototype</code>没有原型对象</strong>：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> proto <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span> <span class="token comment">// null</span>
</code></pre></div><p>下面是两个验证例子，有疑虑的同学多写几个测试用例印证一下。</p> <p><strong>字符串原型链的终点</strong>：<code>Object.prototype</code></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> test <span class="token operator">=</span> <span class="token string">'由String函数构造出来的'</span>
<span class="token keyword">let</span> stringPrototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>test<span class="token punctuation">)</span> <span class="token comment">// 字符串的原型</span>
stringPrototype <span class="token operator">===</span> <span class="token class-name">String</span><span class="token punctuation">.</span>prototype <span class="token comment">// true 字符串的原型是String对象</span>
Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>stringPrototype<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype <span class="token comment">// true String对象的原型是Object对象</span>
</code></pre></div><p><strong>函数原型链的终点</strong>:<code>Object.prototype</code></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> <span class="token function-variable function">test</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
<span class="token keyword">let</span> fnPrototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>test<span class="token punctuation">)</span>
fnPrototype <span class="token operator">===</span> <span class="token class-name">Function</span><span class="token punctuation">.</span>prototype <span class="token comment">// true test的原型是Function.prototype</span>
Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype <span class="token comment">// true</span>
</code></pre></div><h3 id="原型链用来做什么"><a href="#原型链用来做什么" class="header-anchor">#</a> 原型链用来做什么？</h3> <h4 id="属性查找"><a href="#属性查找" class="header-anchor">#</a> 属性查找：</h4> <blockquote><p>如果试图访问对象(实例instance)的某个属性,会首先在对象内部寻找该属性,直至找不到,然后才在该对象的原型(instance.prototype)里去找这个属性，以此类推</p></blockquote> <p>我们用一个例子来形象说明一下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> test <span class="token operator">=</span> <span class="token string">'由String函数构造出来的'</span>
<span class="token keyword">let</span> stringPrototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>test<span class="token punctuation">)</span> <span class="token comment">// 字符串的原型</span>
stringPrototype <span class="token operator">===</span> <span class="token class-name">String</span><span class="token punctuation">.</span>prototype <span class="token comment">// true 字符串的原型是String对象</span>
Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>stringPrototype<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype <span class="token comment">// true String对象的原型是Object对象</span>
</code></pre></div><p>当你访问<code>test</code>的某个属性时，浏览器会进行以下查找：</p> <ol><li>浏览器首先查找<code>test</code> 本身</li> <li>接着查找它的原型对象：<code>String.prototype</code></li> <li>最后查找<code>String.prototype</code>的原型对象：<code>Object.prototype</code></li> <li>一旦在原型链上找到该属性，就会立即返回该属性，停止查找。</li> <li>原型链上的原型都没有找到的话，返回<code>undefiend</code></li></ol> <p>这种查找机制还解释了字符串为何会有自带的方法: <code>slice</code>/<code>split</code>/<code>indexOf</code>等。</p> <p>准确的说：</p> <ul><li>这些属性和方法是定义在<code>String</code>这个全局对象/函数上的。</li> <li>字符串的原型指向了<code>String</code>函数的<code>prototype</code>。</li> <li>之后通过查找原型链，在String函数的<code>prototype</code>中找到这些属性和方法。</li></ul> <h4 id="拒绝查找原型链"><a href="#拒绝查找原型链" class="header-anchor">#</a> 拒绝查找原型链：</h4> <p><code>hasOwnProperty</code>: 指示对象自身属性中是否具有指定的属性</p> <p>语法：<code>obj.hasOwnProperty(prop)</code></p> <p>参数: <code>prop</code> 要查找的属性</p> <p>返回值: 用来判断某个对象是否含有指定的属性的<code>Boolean</code>。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> test <span class="token operator">=</span><span class="token punctuation">{</span> <span class="token string">'OBKoro1'</span><span class="token operator">:</span> <span class="token string">'扣肉'</span> <span class="token punctuation">}</span>
test<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span><span class="token string">'OBKoro1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// true</span>
test<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span><span class="token string">'toString'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false test本身没查找到toString </span>
</code></pre></div><p>这个<code>API</code>是挂载在<code>object.prototype</code>上，所有对象都可以使用，API会忽略掉那些从原型链上继承到的属性。</p> <h2 id="扩展"><a href="#扩展" class="header-anchor">#</a> 扩展：</h2> <h3 id="实例的属性"><a href="#实例的属性" class="header-anchor">#</a> 实例的属性</h3> <p>你知道构造函数的实例对象上有哪些属性吗？这些属性分别挂载在哪个地方？原因是什么？</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>some <span class="token operator">=</span> <span class="token string">'222'</span>
    <span class="token keyword">let</span> ccc <span class="token operator">=</span> <span class="token string">'ccc'</span>
    foo<span class="token punctuation">.</span>obkoro1 <span class="token operator">=</span> <span class="token string">'obkoro1'</span>
    foo<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token string">'aaa'</span>
<span class="token punctuation">}</span>
foo<span class="token punctuation">.</span>koro <span class="token operator">=</span> <span class="token string">'扣肉'</span>
foo<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>test <span class="token operator">=</span> <span class="token string">'test'</span>
<span class="token keyword">let</span> foo1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// `foo1`上有哪些属性,这些属性分别挂载在哪个地方</span>
foo<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>test <span class="token operator">=</span> <span class="token string">'test2'</span> <span class="token comment">// 重新赋值</span>
</code></pre></div><p>上面这道是考察<code>JS</code>基础的题，很多人都没说对，原因是没有彻底掌握<code>this</code>、<code>原型链</code>、<code>函数</code>。</p> <h4 id="想一下再看解析"><a href="#想一下再看解析" class="header-anchor">#</a> 想一下再看解析：</h4> <h4 id="想一下再看解析-2"><a href="#想一下再看解析-2" class="header-anchor">#</a> 想一下再看解析：</h4> <h4 id="想一下再看解析-3"><a href="#想一下再看解析-3" class="header-anchor">#</a> 想一下再看解析：</h4> <h4 id="想一下再看解析-4"><a href="#想一下再看解析-4" class="header-anchor">#</a> 想一下再看解析：</h4> <h4 id="想一下再看解析-5"><a href="#想一下再看解析-5" class="header-anchor">#</a> 想一下再看解析：</h4> <ol><li><code>this.some</code>：<code>foo1</code>对象的属性</li></ol> <p>通过构造调用<code>foo</code>的<code>this</code>指向<code>foo1</code>，所以<code>this.some</code>挂载在<code>foo1</code>对象下。</p> <p>属性查找: <code>foo1.some</code></p> <p><code>foo1.some</code>直接读取<code>foo1</code>的属性。</p> <ol start="2"><li><code>foo1.test</code>、<code>foo1.a</code>：<code>foo1</code>对象的原型</li></ol> <p>根据上文提到的：构造/new调用函数的时候会创建一个新对象(<code>foo1</code>)，自动将<code>foo1</code>的原型(<code>Object.getPrototypeOf(foo1)</code>)指向构造函数的prototype对象。</p> <p>构造调用会执行函数，所以<code>foo.prototype.a = 'aaaaa'</code>也会执行，单就赋值这个层面来说写在<code>foo</code>外面和写在<code>foo</code>里面是一样的。</p> <p>属性查找：<code>foo1.test</code>、<code>foo1.a</code></p> <ul><li><code>foo1</code>本身没有找到,继续查找</li> <li><code>foo1</code>的原型<code>Object.getPrototypeOf(foo1)</code>上找到了<code>a</code>和<code>test</code>，返回它们，停止查找。</li></ul> <ol start="3"><li><code>foo1.obkoro1</code>和<code>foo1.koro</code>：返回undefined</li></ol> <h4 id="静态属性-foo-obkoro1、foo-koro"><a href="#静态属性-foo-obkoro1、foo-koro" class="header-anchor">#</a> 静态属性: <code>foo.obkoro1</code>、<code>foo.koro</code></h4> <blockquote><p>函数在JS中是一等公民，它也是一个对象, 用来模拟类。</p></blockquote> <p>这两个属性跟<code>foo1</code>没有关系，它是对象<code>foo</code>上的两个属性(类似函数的:<code>arguments</code>/<code>prototype</code>/<code>length</code>等属性)，称为<strong>静态属性</strong>。</p> <p>它们只能通过<code>foo.obkoro1</code>和<code>foo.koro</code>来访问。</p> <h4 id="原型对象改变-原型链下游获取的值也会改变"><a href="#原型对象改变-原型链下游获取的值也会改变" class="header-anchor">#</a> 原型对象改变，原型链下游获取的值也会改变</h4> <p>上面那个例子中的<code>foo1.test</code>的值是什么？</p> <div class="language-js extra-class"><pre class="language-js"><code>foo<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>test <span class="token operator">=</span> <span class="token string">'test'</span>
<span class="token keyword">let</span> foo1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// `foo1`上有哪些属性,这些属性分别挂载在哪个地方</span>
foo<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>test <span class="token operator">=</span> <span class="token string">'test2'</span> <span class="token comment">// 重新赋值</span>
</code></pre></div><p><code>foo1.test</code>的值是<code>test2</code>，原因是：<code>foo1</code>的原型对象是<code>Object.getPrototypeOf(foo1)</code>存的指针，指向<code>foo.prototype</code>的内存地址，不是拷贝，每次读取的值都是当前<code>foo.prototype</code>的最新值。</p> <p><strong>打印<code>foo1</code></strong>：</p> <p><img src="https://github.com/OBKoro1/articleImg_src/blob/master/2019/2019_8_25_prototype.png?raw=true" alt=""></p> <h3 id="小结"><a href="#小结" class="header-anchor">#</a> 小结</h3> <p>写了好几天，之前网上很多图文博客，那些线指来指去，就我个人看来还是比较难以理解的，所以本文纯文字的形式来描述这些概念，相信认真看完的同学肯定都有所收获，如果没看懂的话，建议多看几遍，这部分概念真的很重要！</p> <p>PS：实际上还有很多引申出来的东西没写全，准备放到其他文章中去写。</p> <h4 id="觉得我的博客对你有帮助的话-就给我点个star吧"><a href="#觉得我的博客对你有帮助的话-就给我点个star吧" class="header-anchor">#</a> 觉得我的博客对你有帮助的话，就给我点个<a href="https://github.com/OBKoro1/web_accumulate" target="_blank" rel="noopener noreferrer">Star<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>吧！</h4> <p><a href="http://obkoro1.com/web_accumulate/" target="_blank" rel="noopener noreferrer">前端进阶积累<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>、<a href="https://user-gold-cdn.xitu.io/2018/5/1/1631b6f52f7e7015?w=344&amp;h=344&amp;f=jpeg&amp;s=8317" target="_blank" rel="noopener noreferrer">公众号<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>、<a href="https://github.com/OBKoro1" target="_blank" rel="noopener noreferrer">GitHub<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>、wx:OBkoro1、邮箱：obkoro1@foxmail.com</p> <p>以上2019/8/25</p> <p>作者：<a href="https://github.com/OBKoro1" target="_blank" rel="noopener noreferrer">OBKoro1<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>参考资料：</p> <p><a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Objects/Object_prototypes" target="_blank" rel="noopener noreferrer">MDN:对象原型<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://juejin.im/post/58f94c9bb123db411953691b#heading-14" target="_blank" rel="noopener noreferrer">JS原型链与继承别再被问倒了<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://github.com/creeperyang/blog/issues/9" target="_blank" rel="noopener noreferrer">从__proto__和prototype来深入理解JS对象和原型链<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/vue-press-grid/knows/js/Object.defineProperty.html" class="prev">
        一次弄懂 Object.defineProperty
      </a></span> <span class="next"><a href="/vue-press-grid/knows/js/shakeOrthrottle.html">
        /knows/js/shakeOrthrottle.html
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/vue-press-grid/assets/js/app.ced59b00.js" defer></script><script src="/vue-press-grid/assets/js/2.b1aa8411.js" defer></script><script src="/vue-press-grid/assets/js/24.189c29c1.js" defer></script>
  </body>
</html>
